import sys;

def walldecomp(n,t):
	"""
	Compute the wall-and-chamber decomposition of the movable cone of the Hilbert scheme of n points on a very general 2t-polarized K3 surface (Picard rank = 1).
	The function also prints the slopes of all walls inside the movable cone.
	Based on the results of the paper "MMP for moduli of sheaves on K3s via wall-crossing: nef and movable cones, Lagrangian fibrations" by A. Bayer and E. MacrÃ¬.

	Parameters
	----------

	n : int
		The number of points of the Hilbert scheme.
	t : int
		Half of the polarization of the K3 surface.
	
	Returns
	----------

	int
		The number of Kahler-type chambers in the decomposition of the movable cone.

	"""

	N = t*(n-1);
	
	#List of slopes of the walls inside the movable cone
	L = []

	xx = 0;

	print("n =", n, ", t =", t)

	cf = continued_fraction(sqrt(N))
	for i in range(2000):
		x = cf.numerator(i)
		if (x % (n-1) != 1) & (x % (n-1) != (n-2)):
			continue
		y = cf.denominator(i)	
		if x^2 - N*y^2 == 1:
			break

	for yy in range(1, 2000000):
		if ((t*yy*yy + 1) % (n-1) != 0):
			continue
		if (((t*yy*yy + 1)/(n-1)).is_square() == False):
			continue
		xx = ((t*yy*yy + 1)/(n-1)).sqrt();
		break

	flag = 0;

	if xx != 0:
		slope_mov = t*yy/((n-1)*xx);
		if n != 2:
			print("(n-1)X^2 - tY^2 = 1 has solutions.") 
	else:
		if N.is_square():
			slope_mov = sqrt(N)/(n-1);
			print(f"t*(n-1) = {N} is a square.")
		else:
			slope_mov = t*y/x;
			flag = 1;

	print("Slope second wall of movable cone:", slope_mov)

	if flag == 1:
		if (y % 2 != 0) | ((x % (2*(n-1)) != 1) & (x % (2*(n-1)) != (2*n-3))):
			print("Second wall of the movable cone is not HC contraction.")
			flag = 0;


	#Look for Mukai vectors of square >= -2 
	top = floor((n-1)/4)+1 if (n-1) % 4 != 0 else (n-1)/4;
	for rho in range(-1, top):
		for alpha in range(0,n):
			count = 0;
			m = alpha^2 - 4*rho*(n-1);
			if ((m < 0) | ((t*t - N*slope_mov*slope_mov).sign() == 0)):
				topy = 200000;
			else:
				topy = ceil((m*slope_mov*slope_mov)/(4*t*t-4*N*slope_mov*slope_mov).sqrt());
			for Y in range(0, topy+1):
				testX = m + 4*N*Y*Y;
				if (testX).is_square():
					X = sqrt(testX);
					if X == 0:
						continue
					if (X % (2*(n-1)) != alpha) & (X % (2*(n-1)) != (2*n-2-alpha)):
						continue
					if (2*t*Y/X) in L:
						continue
					L.append(2*t*Y/X);


	L.sort();

	for a in range(1, len(L)):
		if L[a] >= slope_mov:
			break

	print("Number of chambers in the movable cone:", len(L[:a+1])-1)
	print("Slope of walls:", L[:a+1])

	if flag == 1:
		d = gcd((n-1)*y, x-1);
		xgen = (n-1)*y/d;
		ygen = (x-1)/d;
		q = 2*t*xgen*xgen - 2*(n-1)*ygen*ygen;
		print(f"Axis of reflection is generated by ({xgen}, {ygen}), of square {q}")

		if ygen/xgen in L:
			print("Reflection with respect to a wall.")
		else:
			print("Reflection axis inside a chamber.")

	return len(L[:a+1])-1

